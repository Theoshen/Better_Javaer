# 《To Be a Better Javaer》-- 数据结构&算法 vol.3：线性表

## 线性表的基本概念

​	线性表是最基本和最常用的一类数据结构，它表示的是线性结构。

​	在线性结构中，数据元素之间存在一对一的关系，其特点是数据元素之间按某种规定存在一个顺序关系。

### 线性表的定义

​	线性表：**n 个同类型数据元素**的**有限序列**（ n 可以为 0），记为：

```
L = (a1, a2, a3, ...ai, ..., an)

L为表名;
i为数据元素ai在线性表中的位序;
n为线性表的表长, n = 0 时称为空表;
```

​	首先它是一个序列。元素之间是有顺序的，若元素存在多个，则第一个元素无前驱，最后一个元素无后继，其他每个元素都有且只有一个**前驱**和**后继**

### 线性表的基本操作

​	一个数据结构的基本操作是指其最核心、最基本的操作。其他较复杂的操作可通过调用其基本操作来实现。线性表的主要操作如下：

```c++
InitList(&L)： 初始化表。构造一个空的线性表。
Length(L)：求表长。返回线性表 L 的长度，即 L 中数据元素的个数。
LocateElem(L , e )：按值查找操作。在表 L 中查找具有给定关键宇值的元素。
GetElem(L ,i)：按位查找操作。获取表 L 中第 i 个位置的元素的值。
Listinsert(&L ，i ， e )：插入操作。在表 L 中的第 i 个位置上插入指定元素 e 。
ListDelete ( &L , i ，e)：删除操作。 删除表 L 中第 i 个位置的元素，并用 e 返回删除元素的值。
PrintList(L)：输出操作。按前后顺序输出线性表 L 的所有元素值。
Empty(L)：判空操作。若 L 为空表， 则返回 true ，否则返回 false 。
DestroyList ( &L )：销毁操作。销毁线性表，井释放线性表 L 所占用的内存空间。
```

## 线性表的顺序存储结构

### 顺序存储定义

​	线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素

![image-20201207161421667](D:\.md\studying\数据结构\线性表的顺序存储结构.png)

### 顺序存储方式

顺序存储结构需要三个属性：

- 存储空间的起始位置：数组**data**，它的存储位置就是存储空间的存储位置
- 线性表的最大存储容量：数组长度**MaxSize**
- 线性表的当前长度：**length**

```c++
typedef int ElemType;          /* ElemType类型根据实际情况而定，这里假设为int */

typedef struct
{          
    ElemType data[MAXSIZE];    /* 数组存储数据元素，最大值为MAXSIZE */    
    int length;                /* 线性表当前长度 */

} SqList;
```

> 数组长度和线性表长度的区别：
>
> ​	数组的长度是存放线性表的存储空间的长度，存储分配后这个量是一般不变的。
>
> ​	线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量会发生变化。

### 地址计算方法

​	存储器中的每个存储单元都有自己的编号，这个编号称为地址	

​	每个数据元素，都需要占用一定的存储单元空间。假设占用的是 `c` 个存储单元，那么线性表中第 `i+1` 个数据元素的存储位置和第 `i` 个数据元素的存储位置满足下列关系：
$$
LOC(a 
i+1
​	
 )=LOC(a 
i
​	
 )+c
$$

> LOC表示获得存储位置的函数

​	第 `i` 个数据元素 `ai` 的存储位置可以由 `a1` 推算得出：
$$
LOC(a 
i
​	
 )=LOC(a 
1
​	
 )+(i−1)∗c
$$
​	对每个线性表位置的存入或者取出数据，对于计算机来说都是相等的时间，也就是一个常数，存取时间性能为O(1) 。通常把具有这一特点的存储结构称为**随机存取结构**

## 顺序存储结构的插入与删除

### 获取元素

​	获得元素操作，就是实现 **GetElem** 操作，即将线性表 `L` 中的第 `i` 个位置元素值返回：

```c++
#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
typedef int Status;
/* Status是函数的类型，其值是函数结果状态代码，如OK等 */
/* 初始条件：顺序线性表L已存在，1 ≤ i ≤ ListLength(L) */
/* 操作结果：用e返回L中第i个数据元素的值 */
Status GetElem(SqList L, int i, ElemType *e)
{    
    if (L.length == 0 || i < 1 ||         i > L.length)
            return ERROR;    
    *e = L.data[i - 1];    
    return OK;
}
```

​	返回值类型**Status**是一个整型，返回**OK**代表**1**，**ERROR**代表**0**

### 插入操作

​	第 i 个数据元素之前插入新数据元素 x 

-  (a1 ,a2 ,...,ai-1 ,ai ,ai+1,...,an ) → (a1 ,a2 ,...,ai-1 ,x,ai ,ai+1,...,an )

![image-20201207161549537](upload\image-20201207161549537.png)

插入的步骤：

1. 检查插入位置是否合法，如果合法则继续，否则退出；
2. 判表是否已占满；因为是事先分配空间，可能存在所分配 存储空间全部被占用的情况，此时也不能实现插入。
3. 若前面检查通过则数据元素依次向后移动一个位置；为避免覆盖原数据，应从最后一个向前依次移动。
4. 将要插入元素填入位置 **i** 处；
5. 表长加 1 。

实现代码：

```c++
/* 初始条件：顺序线性表L已存在，1 ≤ i ≤ ListLength(L) */
/* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */
Status ListInsert(SqList *L, int i, ElemType e)
{    
    int k;    
    if (L->length == MAXSIZE)                            //顺序线性表已经满
        return ERROR;        
    if (i < 1 || i >L->length + 1)                       //当i不在范围内时             
        return ERROR;    
    if (i <= L->length)                                  //若插入数据位置不在表尾
    {         
        for (k = L->length - 1; k >= i - 1; k--)         //将要插入位置后数据元素向后移动一位   
              L->data[k + 1] = L->data[k];    
     }    
     L->data[i - 1] = e;                                 //插入新元素             
     L->length++;    
     return OK;
}
```

### 删除操作

- (a1 ,a2 ,...,ai-1 ,ai ,ai+1,...,an ) → (a1 ,a2 ,...,ai-1 ,ai+1,...,an )

![image-20201219155948757](C:\Users\62566\AppData\Roaming\Typora\typora-user-images\image-20201219155948757.png)

删除的步骤：

1. 检查删除位置是否合法；
2. 若检查通过，数据元素依次向前移动一个位置；
3. 表长减 1 。

```c++
/* 初始条件：顺序线性表L已存在，1≤i≤   ListLength(L) */
/* 操作结果：删除L的第i个数据元素，并用e返回   其值，L的长度减1 */
Status ListDelete(SqList *L, int i, ElemType *e)
{    int k;    

    if (L->length == 0)                  /* 线性表为空 */             
        return ERROR;    

    if (i < 1 || i > L->length)          /* 删除位置不正确 */          
        return ERROR;    
    *e = L->data[i - 1];    

    if (i < L->length)                   /* 如果删除不是最后位置 */      
    {        

        for (k = i; k < L->length; k++)  /* 将删除位置后继元素前移 */             
            L->data[k - 1] = L->data[k];    
    }    
    L->length--;    
    return OK;
}
```

线性表的顺序存储结构，在存、读数据时，不管是哪个位置，时间复杂度都是 O(1) ；而插入或删除时，时间复杂度都是 O(n)

### 线性表的优缺点

#### 缺点

- 插入和删除操作需要移动大量元素
- 当线性表长度变化较大时，难以确定存储空间的容量
- 造成存储空间的＂碎片＂

#### 优点

- 无须为表示表中元素之间的逻辑关系儿增加额外的存储空间
- 可以快速地存取表中任一位置的元素



## 线性表的链式存储结构

顺序存储结构再插入与删除时需要移动大量的元素，非常耗费时间。链式结构正好解决这一痛点

### 定义

用一组任意的存储单元存储在线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。这些数据元素可以存在内存未被占用的任意位置

